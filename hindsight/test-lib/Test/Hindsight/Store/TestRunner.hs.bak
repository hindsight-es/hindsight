{-# LANGUAGE AllowAmbiguousTypes #-}
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE DeriveAnyClass #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE OverloadedRecordDot #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE TypeApplications #-}
{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -Wno-orphans #-}

module Test.Hindsight.Store.TestRunner where

import Control.Concurrent (MVar, newEmptyMVar, putMVar, takeMVar)
import Control.Exception (SomeException (..), fromException)
import Control.Monad (forM, forM_, replicateM, replicateM_)
import Data.IORef
import Data.Map.Strict qualified as Map
import Data.Maybe (mapMaybe)
import Data.Text (Text)
import Data.Typeable (cast)
import Data.UUID.V4 qualified as UUID
import Hindsight.Core (SomeLatestEvent)
import Hindsight.Store
import System.Random (randomRIO)
import Test.Hindsight.Examples (UserCreated, UserInformation2 (..))
import Test.Hindsight.Store.Common
import Control.Concurrent (threadDelay)
import Test.Tasty
import Test.Tasty.HUnit
import UnliftIO.Async (async, concurrently, wait, waitCatch)
import UnliftIO.Exception (throwIO)

-- | Test runner for event store tests
data EventStoreTestRunner backend = EventStoreTestRunner
  { withStore :: forall a. (BackendHandle backend -> IO a) -> IO (),
    -- | For multi-instance tests: provides N handles to the same backend storage
    -- Simulates multiple processes accessing the same backend
    withStores :: forall a. Int -> ([BackendHandle backend] -> IO a) -> IO ()
  }

-- | Common event store test cases split into basic and consistency tests
genericEventStoreTests ::
  forall backend.
  (EventStore backend, StoreConstraints backend IO, Show (Cursor backend)) =>
  EventStoreTestRunner backend ->
  [TestTree]
genericEventStoreTests runner =
  [ testGroup
      "Basic Tests"
      [ testCase "Basic Event Reception" $ runTest runner (testBasicEventReception ),
        testCase "Correlation ID Preservation" $ runTest runner (testCorrelationIdPreservation ),
        testCase "Single Stream Selection" $ runTest runner (testSingleStreamSelection ),
        testCase "Start From Position" $ runTest runner (testStartFromPosition ),
        repeatTest 20 "Async Subscription Reception" $ runTest runner (testAsyncSubscription ),
        testCase "Subscription Honors Stop Result" $ runTest runner (testSubscriptionStopBehavior ),
        testCase "Handler Exception Enrichment" $ runTest runner (testHandlerExceptionEnrichment )
      ],
    testGroup
      "Stream Version Tests"
      [ testCase "Stream Versions Start At 1" $ runTest runner (testStreamVersionsStartAt1 ),
        testCase "Stream Versions Are Contiguous" $ runTest runner (testStreamVersionsContiguous ),
        testCase "Stream Versions Exposed In Subscription" $ runTest runner (testStreamVersionExposedInSubscription ),
        testCase "Multiple Streams Have Independent Versions" $ runTest runner (testIndependentStreamVersions )
      ],
    testGroup
      "Consistency Tests"
      [ testCase "No Stream Condition" $ runTest runner (testNoStreamCondition ),
        testCase "Stream Exists Condition" $ runTest runner (testStreamExistsCondition ),
        testCase "Exact Version Condition" $ runTest runner (testExactVersionCondition ),
        testCase "Exact Stream Version Condition" $ runTest runner (testExactStreamVersionCondition ),
        testCase "Concurrent Writes" $ runTest runner (testConcurrentWrites ),
        testCase "Batch Atomicity" $ runTest runner (testBatchAtomicity ),
        testCase "Multi-Stream Consistency" $ runTest runner (testMultiStreamConsistency ),
        testCase "Version Expectation Race Condition" $ runTest runner (testVersionExpectationRaceCondition ),
        testCase "Any Expectation Concurrency" $ runTest runner (testAnyExpectationConcurrency ),
        testCase "Mixed Version Expectations" $ runTest runner (testMixedVersionExpectations ),
        testCase "Cascading Version Dependencies" $ runTest runner (testCascadingVersionDependencies ),
        testCase "Multi-Stream Head Consistency" $ runTest runner (testMultiStreamHeadConsistency ),
        testCase "Empty Batch Insertion" $ runTest runner (testEmptyBatchInsertion ),
        testCase "Mixed Empty and Non-Empty Streams" $ runTest runner (testMixedEmptyStreams )
      ]
  ]

-- | Multi-instance test cases (for backends that support cross-process subscriptions)
multiInstanceTests ::
  forall backend.
  (EventStore backend, StoreConstraints backend IO, Show (Cursor backend)) =>
  EventStoreTestRunner backend ->
  [TestTree]
multiInstanceTests runner =
  [ testGroup
      "Multi-Instance Tests"
      [ testCase "Multi-Instance Subscriptions (2 instances)" $ runMultiInstanceTest runner 2 (testMultiInstanceSubscription ),
        testCase "Multi-Instance Subscriptions (5 instances)" $ runMultiInstanceTest runner 5 (testMultiInstanceSubscription )
      ]
  ]

repeatTest :: Int -> TestName -> Assertion -> TestTree
repeatTest n name assertion =
  testGroup (name <> " x" <> show n) $
    replicate n $
      testCase name assertion

-- | Run a test with the test runner
runTest :: EventStoreTestRunner backend -> (BackendHandle backend -> IO ()) -> IO ()
runTest runner action = withStore runner action

-- | Run a multi-instance test with the test runner
runMultiInstanceTest :: EventStoreTestRunner backend -> Int -> ([BackendHandle backend] -> IO ()) -> IO ()
runMultiInstanceTest runner n action = withStores runner n action

-- | Helper functions
collectEventsUntilTombstone :: IORef [EventEnvelope UserCreated backend] -> EventHandler UserCreated IO backend
collectEventsUntilTombstone ref event = do
  atomicModifyIORef' ref (\events -> (event : events, ()))
  pure Continue

handleTombstone :: MVar () -> EventHandler Tombstone IO backend
handleTombstone completionVar _ = do
  putMVar completionVar ()
  pure Stop

extractUserInfo :: EventEnvelope UserCreated backend -> Maybe UserInformation2
extractUserInfo envelope = cast envelope.payload

-- Basic Test implementations --

testBasicEventReception :: forall backend. (EventStore backend, StoreConstraints backend IO, Show (Cursor backend)) => BackendHandle backend -> IO ()
testBasicEventReception store = do
  streamId <- StreamId <$> UUID.nextRandom
  receivedEvents <- newIORef []
  completionVar <- newEmptyMVar

  let testEvents = map makeUserEvent [1 .. 3] ++ [makeTombstone]
  result <- insertEvents store Nothing (Transaction (Map.fromList [(streamId, StreamWrite Any testEvents)]))

  case result of
    FailedInsertion err -> assertFailure $ "Failed to insert events: " ++ show err
    SuccessfulInsertion _ -> do
      handle <-
        subscribe
          store
          ( match UserCreated (collectEventsUntilTombstone receivedEvents)
              :? match Tombstone (handleTombstone completionVar)
              :? MatchEnd
          )
          EventSelector {streamId = AllStreams, startupPosition = FromBeginning}

      takeMVar completionVar
      handle.cancel -- Cancel subscription after completion
      events <- reverse <$> readIORef receivedEvents
      length events @?= 3

      let userInfos = mapMaybe extractUserInfo events
      length userInfos @?= 3
      let userNames :: [Text]
          userNames = map userName userInfos
      userNames @?= ["user1", "user2", "user3"]

testSingleStreamSelection :: forall backend. (EventStore backend, StoreConstraints backend IO) => BackendHandle backend -> IO ()
testSingleStreamSelection store = do
  stream1 <- StreamId <$> UUID.nextRandom
  stream2 <- StreamId <$> UUID.nextRandom
  receivedEvents <- newIORef []
  completionVar <- newEmptyMVar

  _ <- insertEvents store Nothing (multiEvent stream1 Any (map makeUserEvent [1 .. 3]))
  _ <- insertEvents store Nothing (multiEvent stream2 Any (map makeUserEvent [4 .. 6]))
  _ <- insertEvents store Nothing (Transaction (Map.fromList [(stream1, StreamWrite Any [makeTombstone])]))

  handle <-
    subscribe
      store
      ( match UserCreated (collectEventsUntilTombstone receivedEvents)
          :? match Tombstone (handleTombstone completionVar)
          :? MatchEnd
      )
      EventSelector {streamId = SingleStream stream1, startupPosition = FromBeginning}

  takeMVar completionVar
  handle.cancel -- Cancel subscription after completion
  events <- reverse <$> readIORef receivedEvents
  let userInfos = mapMaybe extractUserInfo events
  length userInfos @?= 3
  let userNames = map userName userInfos
  userNames @?= ["user1", "user2", "user3"]

testStartFromPosition :: forall backend. (EventStore backend, StoreConstraints backend IO, Show (Cursor backend)) => BackendHandle backend -> IO ()
testStartFromPosition store = do
  streamId <- StreamId <$> UUID.nextRandom
  let testEvents = map makeUserEvent [1 .. 5]

  result <- insertEvents store Nothing (Transaction (Map.fromList [(streamId, StreamWrite Any (take 3 testEvents))]))
  case result of
    FailedInsertion err -> assertFailure $ "Failed to insert first batch: " ++ show err
    SuccessfulInsertion cursor -> do
      _ <- insertEvents store Nothing (Transaction (Map.fromList [(streamId, StreamWrite Any (drop 3 testEvents))]))
      _ <- insertEvents store Nothing (Transaction (Map.fromList [(streamId, StreamWrite Any [makeTombstone])]))

      receivedEvents <- newIORef []
      completionVar <- newEmptyMVar

      handle <-
        subscribe
          store
          ( match UserCreated (collectEventsUntilTombstone receivedEvents)
              :? match Tombstone (handleTombstone completionVar)
              :? MatchEnd
          )
          EventSelector {streamId = AllStreams, startupPosition = FromLastProcessed cursor}

      takeMVar completionVar
      handle.cancel -- Cancel subscription after completion
      events <- reverse <$> readIORef receivedEvents
      let userInfos = mapMaybe extractUserInfo events
      length userInfos @?= 2
      let userNames :: [Text]
          userNames = map userName userInfos
      userNames @?= ["user4", "user5"]

testCorrelationIdPreservation :: forall backend. (EventStore backend, StoreConstraints backend IO, Show (Cursor backend)) => BackendHandle backend -> IO ()
testCorrelationIdPreservation store = do
  streamId <- StreamId <$> UUID.nextRandom
  corrId <- CorrelationId <$> UUID.nextRandom
  receivedEvents <- newIORef []
  completionVar <- newEmptyMVar

  let testEvents = map makeUserEvent [1 .. 3] ++ [makeTombstone]
  result <- insertEvents store (Just corrId) (Transaction (Map.fromList [(streamId, StreamWrite Any testEvents)]))

  case result of
    FailedInsertion err -> assertFailure $ "Failed to insert events: " ++ show err
    SuccessfulInsertion _ -> do
      handle <-
        subscribe
          store
          ( match UserCreated (collectEventsUntilTombstone receivedEvents)
              :? match Tombstone (handleTombstone completionVar)
              :? MatchEnd
          )
          EventSelector {streamId = AllStreams, startupPosition = FromBeginning}

      takeMVar completionVar
      handle.cancel -- Cancel subscription after completion
      events <- readIORef receivedEvents
      mapM_ (\evt -> evt.correlationId @?= Just corrId) events

generateDelays :: IO (Int, Int)
generateDelays = do
  let maxDelay = 500000 -- 0.5 seconds in microseconds
  (,) <$> randomRIO (0, maxDelay) <*> randomRIO (0, maxDelay)

testAsyncSubscription :: forall backend. (EventStore backend, StoreConstraints backend IO, Show (Cursor backend)) => BackendHandle backend -> IO ()
testAsyncSubscription store = do
  streamId <- StreamId <$> UUID.nextRandom
  receivedEvents <- newIORef []
  completionVar <- newEmptyMVar

  handle <-
    subscribe
      store
      ( match UserCreated (collectEventsUntilTombstone receivedEvents)
          :? match Tombstone (handleTombstone completionVar)
          :? MatchEnd
      )
      EventSelector {streamId = AllStreams, startupPosition = FromBeginning}

  let testEvents = map makeUserEvent [1 .. 3] ++ [makeTombstone]
  result <- insertEvents store Nothing (Transaction (Map.fromList [(streamId, StreamWrite Any testEvents)]))

  case result of
    FailedInsertion err -> do
      handle.cancel
      assertFailure $ "Failed to insert events: " ++ show err
    SuccessfulInsertion _ -> do
      takeMVar completionVar
      handle.cancel
      events <- reverse <$> readIORef receivedEvents
      length events @?= 3
      let userInfos = mapMaybe extractUserInfo events
      length userInfos @?= 3
      let userNames :: [Text]
          userNames = map userName userInfos
      userNames @?= ["user1", "user2", "user3"]

-- | Test that subscriptions honor the Stop result from handlers
--
-- This is a critical property: when a handler returns Stop, the subscription
-- must not process any subsequent events. This test verifies that all backends
-- correctly implement this behavior.
--
-- Test sequence:
--   1. Insert: [Inc, Inc, Stop, Inc, Inc]
--   2. Handler: increments counter on Inc, returns Stop on Stop event
--   3. Expected: counter = 2 (stopped before processing the last two Incs)
testSubscriptionStopBehavior :: forall backend. (EventStore backend, StoreConstraints backend IO, Show (Cursor backend)) => BackendHandle backend -> IO ()
testSubscriptionStopBehavior store = do
  streamId <- StreamId <$> UUID.nextRandom
  counter <- newIORef (0 :: Int)
  completionVar <- newEmptyMVar

  -- Handler that increments counter and returns Continue
  let handleInc :: EventHandler CounterInc IO backend
      handleInc _ = do
        atomicModifyIORef' counter (\n -> (n + 1, ()))
        pure Continue

  -- Handler that returns Stop (signaling subscription should end)
  let handleStop :: EventHandler CounterStop IO backend
      handleStop _ = do
        putMVar completionVar ()
        pure Stop

  -- Start subscription before inserting events
  handle <-
    subscribe
      store
      ( match CounterInc handleInc
          :? match CounterStop handleStop
          :? MatchEnd
      )
      EventSelector {streamId = AllStreams, startupPosition = FromBeginning}

  -- Insert test sequence: 2 increments, then Stop, then 2 more increments
  let testEvents =
        [ makeCounterInc,    -- counter = 1
          makeCounterInc,    -- counter = 2
          makeCounterStop,   -- STOP HERE - should not process further
          makeCounterInc,    -- should NOT be processed
          makeCounterInc     -- should NOT be processed
        ]

  result <- insertEvents store Nothing (Transaction (Map.fromList [(streamId, StreamWrite Any testEvents)]))

  case result of
    FailedInsertion err -> do
      handle.cancel
      assertFailure $ "Failed to insert events: " ++ show err
    SuccessfulInsertion _ -> do
      -- Wait for the Stop handler to signal completion
      takeMVar completionVar

      -- Give a small grace period to catch any erroneous event processing
      -- If the backend is broken, it might process events after Stop
      threadDelay 100000 -- 100ms

      handle.cancel

      -- Verify counter stopped at 2 (before the Stop event)
      finalCount <- readIORef counter
      finalCount @?= 2

-- | Test that handler exceptions enrich failures with event context
--
-- When a handler throws an exception, the subscription should die (fail-fast).
-- The exception should be enriched with full event metadata for debugging.
--
-- Test sequence:
--   1. Insert: [Inc, Inc, Fail, Inc, Inc]
--   2. Handler: increments counter on Inc, throws exception on Fail
--   3. Expected: counter = 2, subscription dies, events after Fail not processed
testHandlerExceptionEnrichment :: forall backend. (EventStore backend, StoreConstraints backend IO, Show (Cursor backend)) => BackendHandle backend -> IO ()
testHandlerExceptionEnrichment store = do
  streamId <- StreamId <$> UUID.nextRandom
  counter <- newIORef (0 :: Int)

  -- Handler that increments counter and returns Continue
  let handleInc :: EventHandler CounterInc IO backend
      handleInc _ = do
        atomicModifyIORef' counter (\n -> (n + 1, ()))
        pure Continue

  -- Handler that throws a test exception
  let handleFail :: EventHandler CounterFail IO backend
      handleFail _envelope = do
        throwIO $ userError "Test exception from CounterFail handler"

  -- Start subscription before inserting events
  handle <-
    subscribe
      store
      ( match CounterInc handleInc
          :? match CounterFail handleFail
          :? MatchEnd
      )
      EventSelector {streamId = AllStreams, startupPosition = FromBeginning}

  -- Insert test sequence: 2 increments, then Fail (should kill subscription), then 2 more increments
  let testEvents =
        [ makeCounterInc,    -- counter = 1
          makeCounterInc,    -- counter = 2
          makeCounterFail,   -- EXCEPTION HERE - subscription should die
          makeCounterInc,    -- should NOT be processed
          makeCounterInc     -- should NOT be processed
        ]

  result <- insertEvents store Nothing (Transaction (Map.fromList [(streamId, StreamWrite Any testEvents)]))

  case result of
    FailedInsertion err -> do
      handle.cancel
      assertFailure $ "Failed to insert events: " ++ show err
    SuccessfulInsertion _ -> do
      -- Wait long enough for the exception to propagate and kill the subscription
      -- If the subscription dies, it won't process events after Fail
      threadDelay 200000 -- 200ms - generous grace period

      handle.cancel

      -- Verify counter stopped at 2 (subscription died on Fail event)
      finalCount <- readIORef counter
      finalCount @?= 2

-- Consistency Test implementations --

testNoStreamCondition :: forall backend. (EventStore backend, StoreConstraints backend IO, Show (Cursor backend)) => BackendHandle backend -> IO ()
testNoStreamCondition store = do
  streamId <- StreamId <$> UUID.nextRandom

  result1 <-
    insertEvents store Nothing $
      singleEvent streamId NoStream (makeUserEvent 1)

  case result1 of
    FailedInsertion err -> assertFailure $ "First write failed: " ++ show err
    SuccessfulInsertion _ -> do
      result2 <-
        insertEvents store Nothing $
          singleEvent streamId NoStream (makeUserEvent 2)

      case result2 of
        FailedInsertion (ConsistencyError _) -> pure ()
        FailedInsertion err -> assertFailure $ "Unexpected error: " ++ show err
        SuccessfulInsertion _ -> assertFailure "Second write should have failed"

testStreamExistsCondition :: forall backend. (EventStore backend, StoreConstraints backend IO, Show (Cursor backend)) => BackendHandle backend -> IO ()
testStreamExistsCondition store = do
  streamId <- StreamId <$> UUID.nextRandom

  result1 <-
    insertEvents store Nothing $
      appendAfterAny streamId (makeUserEvent 1)

  case result1 of
    FailedInsertion (ConsistencyError _) -> do
      _ <-
        insertEvents store Nothing $
          singleEvent streamId NoStream (makeUserEvent 1)

      result2 <-
        insertEvents store Nothing $
          appendAfterAny streamId (makeUserEvent 2)

      case result2 of
        FailedInsertion err -> assertFailure $ "Second write failed: " ++ show err
        SuccessfulInsertion _ -> pure ()
    FailedInsertion err -> assertFailure $ "Unexpected error: " ++ show err
    SuccessfulInsertion _ -> assertFailure "First write should have failed"

testExactVersionCondition :: forall backend. (EventStore backend, StoreConstraints backend IO, Show (Cursor backend)) => BackendHandle backend -> IO ()
testExactVersionCondition store = do
  streamId <- StreamId <$> UUID.nextRandom

  SuccessfulInsertion initCursor <-
    insertEvents store Nothing $
      singleEvent streamId NoStream (makeUserEvent 42)

  result1 <-
    insertEvents store Nothing $
      singleEvent streamId StreamExists (makeUserEvent 1)

  case result1 of
    FailedInsertion err -> assertFailure $ "First write failed: " ++ show err
    SuccessfulInsertion cursor1 -> do
      -- Write with wrong version should fail
      result2 <-
        insertEvents store Nothing $
          singleEvent streamId (ExactVersion initCursor) (makeUserEvent 2)

      case result2 of
        FailedInsertion (ConsistencyError _) -> do
          -- Write with correct version should succeed
          result3 <-
            insertEvents store Nothing $
              singleEvent streamId (ExactVersion cursor1) (makeUserEvent 3)

          case result3 of
            FailedInsertion err -> assertFailure $ "Third write failed: " ++ show err
            SuccessfulInsertion _ -> pure ()
        FailedInsertion err -> assertFailure $ "Unexpected error: " ++ show err
        SuccessfulInsertion _ -> assertFailure "Second write should have failed"

testConcurrentWrites :: forall backend. (EventStore backend, StoreConstraints backend IO, Show (Cursor backend)) => BackendHandle backend -> IO ()
testConcurrentWrites store = do
  streamId <- StreamId <$> UUID.nextRandom

  -- Initialize stream
  result1 <-
    insertEvents store Nothing $
      singleEvent streamId NoStream (makeUserEvent 1)

  case result1 of
    FailedInsertion err -> assertFailure $ "Initial write failed: " ++ show err
    SuccessfulInsertion cursor -> do
      -- Attempt concurrent writes with same expected version
      (result2, result3) <-
        concurrently
          ( insertEvents store Nothing $
              singleEvent streamId (ExactVersion cursor) (makeUserEvent 2)
          )
          ( insertEvents store Nothing $
              singleEvent streamId (ExactVersion cursor) (makeUserEvent 3)
          )

      -- Exactly one write should succeed
      case (result2, result3) of
        (SuccessfulInsertion _, FailedInsertion (ConsistencyError _)) -> pure ()
        (FailedInsertion (ConsistencyError _), SuccessfulInsertion _) -> pure ()
        _ -> assertFailure "Expected exactly one write to succeed"

testBatchAtomicity :: forall backend. (EventStore backend, StoreConstraints backend IO) => BackendHandle backend -> IO ()
testBatchAtomicity store = do
  streamId1 <- StreamId <$> UUID.nextRandom
  streamId2 <- StreamId <$> UUID.nextRandom

  -- Initialize first stream
  _ <-
    insertEvents store Nothing $
      singleEvent streamId1 NoStream (makeUserEvent 1)

  -- Try batch write with one valid and one invalid condition
  result <-
    insertEvents store Nothing $
      fromWrites
        [ (streamId1, StreamWrite StreamExists [makeUserEvent 2]),
          (streamId2, StreamWrite StreamExists [makeUserEvent 3])
        ]

  -- Entire batch should fail
  case result of
    FailedInsertion (ConsistencyError _) -> pure ()
    _ -> assertFailure "Batch write should have failed completely"

testMultiStreamConsistency :: forall backend. (EventStore backend, StoreConstraints backend IO, Show (Cursor backend)) => BackendHandle backend -> IO ()
testMultiStreamConsistency store = do
  streams@[streamId1, streamId2, streamId3] <- replicateM 3 (StreamId <$> UUID.nextRandom)

  -- Initialize streams with different versions
  let initWrites =
        Transaction (Map.fromList $
          zip streams $
            map
              (\i -> StreamWrite NoStream [makeUserEvent i])
              [1 ..])

  result1 <- insertEvents store Nothing initWrites

  case result1 of
    FailedInsertion err -> assertFailure $ "Initial writes failed: " ++ show err
    SuccessfulInsertion cursor -> do
      -- Try writing to all streams with mix of correct and incorrect versions
      let batch =
            Transaction (Map.fromList
              [ (streamId1, StreamWrite (ExactVersion cursor) [makeUserEvent 4]),
                (streamId2, StreamWrite NoStream [makeUserEvent 5]), -- Should fail
                (streamId3, StreamWrite StreamExists [makeUserEvent 6])
              ])

      result2 <- insertEvents store Nothing batch

      case result2 of
        FailedInsertion (ConsistencyError _) -> pure ()
        _ -> assertFailure "Mixed version batch should fail"

-- Stream version condition tests --

testExactStreamVersionCondition :: forall backend. (EventStore backend, StoreConstraints backend IO, Show (Cursor backend)) => BackendHandle backend -> IO ()
testExactStreamVersionCondition store = do
  streamId <- StreamId <$> UUID.nextRandom

  -- Insert first event
  result1 <-
    insertEvents store Nothing $
      singleEvent streamId NoStream (makeUserEvent 1)

  case result1 of
    FailedInsertion err -> assertFailure $ "First write failed: " ++ show err
    SuccessfulInsertion _ -> do
      -- Try with correct stream version
      result2 <-
        insertEvents store Nothing $
          singleEvent streamId (ExactStreamVersion (StreamVersion 1)) (makeUserEvent 2)

      case result2 of
        FailedInsertion err -> assertFailure $ "Second write with correct stream version failed: " ++ show err
        SuccessfulInsertion _ -> do
          -- Try with wrong stream version (still expecting version 1)
          result3 <-
            insertEvents store Nothing $
              singleEvent streamId (ExactStreamVersion (StreamVersion 1)) (makeUserEvent 3)

          case result3 of
            FailedInsertion (ConsistencyError _) -> pure ()
            FailedInsertion err -> assertFailure $ "Unexpected error: " ++ show err
            SuccessfulInsertion _ -> assertFailure "Third write should have failed with wrong stream version"

testVersionExpectationRaceCondition :: forall backend. (EventStore backend, StoreConstraints backend IO, Show (Cursor backend)) => BackendHandle backend -> IO ()
testVersionExpectationRaceCondition store = do
  streamId <- StreamId <$> UUID.nextRandom

  -- Initialize stream
  result <-
    insertEvents store Nothing $
      singleEvent streamId NoStream (makeUserEvent 0)

  case result of
    FailedInsertion err -> assertFailure $ "Initial write failed: " ++ show err
    SuccessfulInsertion cursor -> do
      -- Race 10 writers all expecting the same version
      results <- forM [1 .. 10] $ \i -> async $ do
        insertEvents store Nothing $
          singleEvent streamId (ExactVersion cursor) (makeUserEvent i)

      outcomes <- mapM wait results
      let successes = [r | r@(SuccessfulInsertion _) <- outcomes]
          failures = [r | r@(FailedInsertion _) <- outcomes]

      length successes @?= 1 -- Exactly one should succeed
      length failures @?= 9 -- All others should fail

      -- Verify all failures are consistency errors
      forM_ failures $ \case
        FailedInsertion (ConsistencyError _) -> pure ()
        _ -> assertFailure "Expected ConsistencyError for version conflict"

testAnyExpectationConcurrency :: forall backend. (EventStore backend, StoreConstraints backend IO) => BackendHandle backend -> IO ()
testAnyExpectationConcurrency store = do
  streamId <- StreamId <$> UUID.nextRandom

  -- Initialize stream
  _ <-
    insertEvents store Nothing $
      singleEvent streamId NoStream (makeUserEvent 0)

  -- Spawn 20 concurrent writers with Any expectation
  start <- newEmptyMVar
  results <- forM [1 .. 20] $ \i -> async $ do
    takeMVar start -- Wait for signal
    insertEvents store Nothing $
      singleEvent streamId Any (makeUserEvent i)

  -- Start all writers simultaneously
  replicateM_ 20 (putMVar start ())

  -- Verify all complete successfully
  outcomes <- mapM wait results
  let successes = [r | r@(SuccessfulInsertion _) <- outcomes]
  length successes @?= 20 -- All should succeed with Any expectation

testMixedVersionExpectations :: forall backend. (EventStore backend, StoreConstraints backend IO) => BackendHandle backend -> IO ()
testMixedVersionExpectations store = do
  -- Create 5 streams
  streams <- replicateM 5 (StreamId <$> UUID.nextRandom)

  -- Initialize some streams
  case streams of
    [s1, s2, s3, s4, s5] -> do
      _ <-
        insertEvents store Nothing $
          Transaction (Map.fromList
            [ (s1, StreamWrite NoStream [makeUserEvent 1]),
              (s3, StreamWrite NoStream [makeUserEvent 3])
            ])

      -- Try batch with mixed expectations
      result <-
        insertEvents store Nothing $
          Transaction (Map.fromList
            [ (s1, StreamWrite StreamExists [makeUserEvent 11]), -- Should succeed
              (s2, StreamWrite NoStream [makeUserEvent 12]), -- Should succeed
              (s3, StreamWrite (ExactStreamVersion (StreamVersion 2)) [makeUserEvent 13]), -- Should fail (wrong version)
              (s4, StreamWrite Any [makeUserEvent 14]), -- Would succeed if batch succeeds
              (s5, StreamWrite StreamExists [makeUserEvent 15]) -- Would fail (stream doesn't exist)
            ])

      -- Entire batch should fail due to any failure
      case result of
        FailedInsertion (ConsistencyError _) -> pure ()
        _ -> assertFailure "Batch with mixed expectations should fail if any expectation fails"
    _ -> assertFailure "Expected exactly 5 streams"

testCascadingVersionDependencies :: forall backend. (EventStore backend, StoreConstraints backend IO, Show (EventStoreError backend)) => BackendHandle backend -> IO ()
testCascadingVersionDependencies store = do
  -- Create a chain of 5 streams
  streams <- replicateM 5 (StreamId <$> UUID.nextRandom)

  -- Build dependency chain: each stream depends on previous
  cursors <- forM (zip [0 ..] streams) $ \(i, stream) -> do
    result <-
      insertEvents store Nothing $
        singleEvent stream NoStream (makeUserEvent i)
    case result of
      SuccessfulInsertion cursor -> pure (stream, cursor)
      FailedInsertion err -> assertFailure $ "Failed to create dependency chain: " ++ show err

  -- Now update middle of chain and verify dependencies
  case cursors of
    [(_, _), (_, _), (s3, c3), (_, _), (_, _)] -> do
      -- Update s3
      result1 <-
        insertEvents store Nothing $
          singleEvent s3 (ExactVersion c3) (makeUserEvent 33)

      case result1 of
        FailedInsertion err -> assertFailure $ "Failed to update middle stream: " ++ show err
        SuccessfulInsertion _ -> do
          -- Old cursor for s3 should now be invalid
          result2 <-
            insertEvents store Nothing $
              singleEvent s3 (ExactVersion c3) (makeUserEvent 333)

          case result2 of
            FailedInsertion (ConsistencyError _) -> pure () -- Expected
            _ -> assertFailure "Should not be able to use old cursor after update"
    _ -> assertFailure "Expected exactly 5 cursors"

-- | Test that stream heads are tracked correctly when multiple streams
-- are inserted in a single transaction. This is validated indirectly by
-- checking that each stream can be appended to independently after a multi-stream insert.
testMultiStreamHeadConsistency :: forall backend. (EventStore backend, StoreConstraints backend IO, Show (Cursor backend)) => BackendHandle backend -> IO ()
testMultiStreamHeadConsistency store = do
  -- Create three distinct streams
  streamA <- StreamId <$> UUID.nextRandom
  streamB <- StreamId <$> UUID.nextRandom
  streamC <- StreamId <$> UUID.nextRandom

  -- Insert multiple events for each stream in a SINGLE transaction
  -- Stream A: 2 events, Stream B: 3 events, Stream C: 1 event
  result <-
    insertEvents store Nothing $
      Transaction (Map.fromList
        [ (streamA, StreamWrite NoStream [makeUserEvent 1, makeUserEvent 2]),
          (streamB, StreamWrite NoStream [makeUserEvent 10, makeUserEvent 20, makeUserEvent 30]),
          (streamC, StreamWrite NoStream [makeUserEvent 100])
        ])

  case result of
    FailedInsertion err -> assertFailure $ "Failed to insert multi-stream batch: " ++ show err
    SuccessfulInsertion{} -> do
      -- Verify each stream can be appended to independently
      -- If stream heads are tracked correctly, StreamExists should work for all streams

      -- Append to stream A
      resultA <-
        insertEvents store Nothing $
          singleEvent streamA StreamExists (makeUserEvent 3)

      case resultA of
        FailedInsertion err -> assertFailure $ "Failed to append to stream A (stream heads may be corrupted): " ++ show err
        SuccessfulInsertion _ -> do
          -- Append to stream B
          resultB <-
            insertEvents store Nothing $
              singleEvent streamB StreamExists (makeUserEvent 40)

          case resultB of
            FailedInsertion err -> assertFailure $ "Failed to append to stream B (stream heads may be corrupted): " ++ show err
            SuccessfulInsertion _ -> do
              -- Append to stream C
              resultC <-
                insertEvents store Nothing $
                  singleEvent streamC StreamExists (makeUserEvent 200)

              case resultC of
                FailedInsertion err -> assertFailure $ "Failed to append to stream C (stream heads may be corrupted): " ++ show err
                SuccessfulInsertion _ -> pure () -- All streams updated successfully

-- | Test that empty batch insertion is handled correctly
testEmptyBatchInsertion :: forall backend. (EventStore backend, StoreConstraints backend IO, Show (Cursor backend)) => BackendHandle backend -> IO ()
testEmptyBatchInsertion store = do
  -- Try to insert completely empty batch
  result <- insertEvents store Nothing (Transaction (Map.empty :: Map.Map StreamId (StreamWrite [] SomeLatestEvent backend)))

  case result of
    FailedInsertion _ -> pure () -- Acceptable to reject empty batches
    SuccessfulInsertion{} -> do
      -- If we allow empty batches, cursor should be valid (no negative sequence numbers)
      -- Can't easily validate cursor structure across backends, but at least
      -- verify we can query with it
      streamId <- StreamId <$> UUID.nextRandom
      result2 <- insertEvents store Nothing $
        appendToOrCreateStream streamId (makeUserEvent 1)
      case result2 of
        FailedInsertion err -> assertFailure $ "Failed follow-up insert after empty batch: " ++ show err
        SuccessfulInsertion _ -> pure ()

-- | Test that streams with zero events in a multi-stream batch are handled correctly
testMixedEmptyStreams :: forall backend. (EventStore backend, StoreConstraints backend IO, Show (Cursor backend)) => BackendHandle backend -> IO ()
testMixedEmptyStreams store = do
  streamA <- StreamId <$> UUID.nextRandom
  streamB <- StreamId <$> UUID.nextRandom
  streamC <- StreamId <$> UUID.nextRandom

  -- Insert batch where one stream has zero events
  -- Stream A: 2 events, Stream B: 0 events, Stream C: 1 event
  result <-
    insertEvents store Nothing $
      Transaction (Map.fromList
        [ (streamA, StreamWrite NoStream [makeUserEvent 1, makeUserEvent 2]),
          (streamB, StreamWrite NoStream []),
          (streamC, StreamWrite NoStream [makeUserEvent 100])
        ])

  case result of
    FailedInsertion err -> assertFailure $ "Failed to insert mixed empty/non-empty batch: " ++ show err
    SuccessfulInsertion{} -> do
      -- Verify stream B (empty) can be created
      resultB <-
        insertEvents store Nothing $
          singleEvent streamB NoStream (makeUserEvent 10)

      case resultB of
        FailedInsertion err -> assertFailure $ "Stream B should not exist yet, but got error: " ++ show err
        SuccessfulInsertion _ -> do
          -- Verify streams A and C can be appended to (they should exist)
          resultA <-
            insertEvents store Nothing $
              singleEvent streamA StreamExists (makeUserEvent 3)

          resultC <-
            insertEvents store Nothing $
              singleEvent streamC StreamExists (makeUserEvent 200)

          case (resultA, resultC) of
            (SuccessfulInsertion _, SuccessfulInsertion _) -> pure ()
            _ -> assertFailure "Streams A and C should exist after mixed batch"

-- Stream Version Test implementations --

-- | Test that stream versions start at 1
testStreamVersionsStartAt1 :: forall backend. (EventStore backend, StoreConstraints backend IO) => BackendHandle backend -> IO ()
testStreamVersionsStartAt1 store = do
  streamId <- StreamId <$> UUID.nextRandom
  receivedVersions <- newIORef []
  completionVar <- newEmptyMVar

  let collectVersions ref event = do
        atomicModifyIORef' ref (\versions -> (event.streamVersion : versions, ()))
        pure Continue

  -- Insert first event
  _ <- insertEvents store Nothing (Transaction (Map.fromList [(streamId, StreamWrite NoStream [makeUserEvent 1, makeTombstone])]))

  handle <-
    subscribe
      store
      ( match UserCreated (collectVersions receivedVersions)
          :? match Tombstone (handleTombstone completionVar)
          :? MatchEnd
      )
      EventSelector {streamId = SingleStream streamId, startupPosition = FromBeginning}

  takeMVar completionVar
  handle.cancel

  versions <- reverse <$> readIORef receivedVersions
  versions @?= [StreamVersion 1]

-- | Test that stream versions are contiguous (no gaps)
testStreamVersionsContiguous :: forall backend. (EventStore backend, StoreConstraints backend IO) => BackendHandle backend -> IO ()
testStreamVersionsContiguous store = do
  streamId <- StreamId <$> UUID.nextRandom
  receivedVersions <- newIORef []
  completionVar <- newEmptyMVar

  let collectVersions ref event = do
        atomicModifyIORef' ref (\versions -> (event.streamVersion : versions, ()))
        pure Continue

  -- Insert 5 events in multiple batches
  _ <- insertEvents store Nothing (Transaction (Map.fromList [(streamId, StreamWrite NoStream [makeUserEvent 1, makeUserEvent 2])]))
  _ <- insertEvents store Nothing (Transaction (Map.fromList [(streamId, StreamWrite StreamExists [makeUserEvent 3])]))
  _ <- insertEvents store Nothing (Transaction (Map.fromList [(streamId, StreamWrite StreamExists [makeUserEvent 4, makeUserEvent 5, makeTombstone])]))

  handle <-
    subscribe
      store
      ( match UserCreated (collectVersions receivedVersions)
          :? match Tombstone (handleTombstone completionVar)
          :? MatchEnd
      )
      EventSelector {streamId = SingleStream streamId, startupPosition = FromBeginning}

  takeMVar completionVar
  handle.cancel

  versions <- reverse <$> readIORef receivedVersions
  -- Should be contiguous: 1, 2, 3, 4, 5
  versions @?= [StreamVersion 1, StreamVersion 2, StreamVersion 3, StreamVersion 4, StreamVersion 5]

-- | Test that stream versions are exposed in subscriptions
testStreamVersionExposedInSubscription :: forall backend. (EventStore backend, StoreConstraints backend IO) => BackendHandle backend -> IO ()
testStreamVersionExposedInSubscription store = do
  streamId <- StreamId <$> UUID.nextRandom
  receivedVersionRef <- newIORef Nothing
  completionVar <- newEmptyMVar

  let captureVersion ref event = do
        atomicModifyIORef' ref (\_ -> (Just event.streamVersion, ()))
        pure Continue

  _ <- insertEvents store Nothing (Transaction (Map.fromList [(streamId, StreamWrite NoStream [makeUserEvent 1, makeTombstone])]))

  handle <-
    subscribe
      store
      ( match UserCreated (captureVersion receivedVersionRef)
          :? match Tombstone (handleTombstone completionVar)
          :? MatchEnd
      )
      EventSelector {streamId = SingleStream streamId, startupPosition = FromBeginning}

  takeMVar completionVar
  handle.cancel

  mbVersion <- readIORef receivedVersionRef
  mbVersion @?= Just (StreamVersion 1)

-- | Test that multiple streams have independent version sequences
testIndependentStreamVersions :: forall backend. (EventStore backend, StoreConstraints backend IO) => BackendHandle backend -> IO ()
testIndependentStreamVersions store = do
  streamA <- StreamId <$> UUID.nextRandom
  streamB <- StreamId <$> UUID.nextRandom
  streamC <- StreamId <$> UUID.nextRandom

  versionsA <- newIORef []
  versionsB <- newIORef []
  versionsC <- newIORef []
  completionVar <- newEmptyMVar

  let collectVersionsFor ref event = do
        atomicModifyIORef' ref (\versions -> (event.streamVersion : versions, ()))
        pure Continue

  -- Insert events to all three streams in mixed order, in the SAME transaction
  _ <- insertEvents store Nothing $ Transaction (Map.fromList
    [ (streamA, StreamWrite NoStream [makeUserEvent 1, makeUserEvent 2])  -- A: versions 1, 2
    , (streamB, StreamWrite NoStream [makeUserEvent 10])                    -- B: version 1
    , (streamC, StreamWrite NoStream [makeUserEvent 100, makeUserEvent 101, makeUserEvent 102])  -- C: versions 1, 2, 3
    ])

  -- Insert more events to verify independent counting
  _ <- insertEvents store Nothing $ Transaction (Map.fromList
    [ (streamA, StreamWrite StreamExists [makeUserEvent 3])  -- A: version 3
    , (streamB, StreamWrite StreamExists [makeUserEvent 11, makeUserEvent 12])  -- B: versions 2, 3
    ])

  -- Add tombstones
  _ <- insertEvents store Nothing $ Transaction (Map.fromList
    [ (streamA, StreamWrite StreamExists [makeTombstone])
    , (streamB, StreamWrite StreamExists [makeTombstone])
    , (streamC, StreamWrite StreamExists [makeTombstone])
    ])

  -- Subscribe to all streams
  remainingTombstones <- newIORef (3 :: Int)
  let handleTombstones _ = do
        remaining <- atomicModifyIORef' remainingTombstones (\n -> (n - 1, n - 1))
        if remaining == 0
          then putMVar completionVar () >> pure Stop
          else pure Continue

  handle <-
    subscribe
      store
      ( match UserCreated (\event -> do
          case event.streamId of
            sid | sid == streamA -> collectVersionsFor versionsA event
                | sid == streamB -> collectVersionsFor versionsB event
                | sid == streamC -> collectVersionsFor versionsC event
                | otherwise -> pure Continue
        )
          :? match Tombstone handleTombstones
          :? MatchEnd
      )
      EventSelector {streamId = AllStreams, startupPosition = FromBeginning}

  takeMVar completionVar
  handle.cancel

  -- Verify each stream has independent version sequences
  vA <- reverse <$> readIORef versionsA
  vB <- reverse <$> readIORef versionsB
  vC <- reverse <$> readIORef versionsC

  vA @?= [StreamVersion 1, StreamVersion 2, StreamVersion 3]
  vB @?= [StreamVersion 1, StreamVersion 2, StreamVersion 3]
  vC @?= [StreamVersion 1, StreamVersion 2, StreamVersion 3]

-- Multi-Instance Test implementations --

-- | Test that multiple "processes" (separate handles) can subscribe to events
-- written by another "process". This validates cross-process notification works.
testMultiInstanceSubscription ::
  forall backend.
  (EventStore backend, StoreConstraints backend IO, Show (Cursor backend)) =>
  [BackendHandle backend] ->
  IO ()
testMultiInstanceSubscription stores = do
  case stores of
    [] -> assertFailure "Expected at least 1 store handle"
    (writerStore : subscriberStores) -> do
      streamId <- StreamId <$> UUID.nextRandom

      -- Create completion vars for each subscriber
      completionVars <- replicateM (length subscriberStores) newEmptyMVar
      receivedEventsRefs <- replicateM (length subscriberStores) (newIORef [])

      -- Start subscriptions on all subscriber stores (simulating separate processes)
      subscriptionHandles <- forM (zip3 subscriberStores completionVars receivedEventsRefs) $
        \(store, completionVar, eventsRef) -> do
          subscribe
            store
            ( match UserCreated (collectEventsUntilTombstone eventsRef)
                :? match Tombstone (handleTombstone completionVar)
                :? MatchEnd
            )
            EventSelector {streamId = AllStreams, startupPosition = FromBeginning}

      -- Write events from the writer store (simulating different process)
      let testEvents = map makeUserEvent [1 .. 5] ++ [makeTombstone]
      result <- insertEvents writerStore Nothing
                  (Transaction (Map.fromList [(streamId, StreamWrite Any testEvents)]))

      case result of
        FailedInsertion err -> do
          -- Cancel all subscriptions on failure
          mapM_ (.cancel) subscriptionHandles
          assertFailure $ "Failed to insert events: " ++ show err
        SuccessfulInsertion{} -> do
          -- Wait for all subscribers to complete
          forM_ completionVars takeMVar

          -- Cancel all subscriptions
          mapM_ (.cancel) subscriptionHandles

          -- Verify all subscribers received the same events
          allReceivedEvents <- mapM (fmap reverse . readIORef) receivedEventsRefs
          forM_ (zip [(1::Int)..] allReceivedEvents) $ \(idx, events) -> do
            length events @?= 5
            let userInfos = mapMaybe extractUserInfo events
            length userInfos @?= 5
            let userNames :: [Text]
                userNames = map userName userInfos
            userNames @?= ["user1", "user2", "user3", "user4", "user5"]

          -- All subscribers should have received identical events
          case allReceivedEvents of
            [] -> pure ()
            (firstEvents : restEvents) -> do
              forM_ restEvents $ \events ->
                length events @?= length firstEvents
