#!/usr/bin/env python3
"""
Post-process Haddock HTML to convert Hackage URLs for local packages to relative paths.

This script fixes cross-package links generated by `cabal haddock-project --hackage`
so that our local packages link to each other relatively, while external packages
still link to Hackage.
"""

import re
import sys
from pathlib import Path

# Our local packages that should use relative links
LOCAL_PACKAGES = {
    'hindsight-core',
    'hindsight-memory-store',
    'hindsight-filesystem-store',
    'hindsight-postgresql-store',
    'hindsight-postgresql-projections',
}

def fix_links_in_file(html_file: Path, haddock_root: Path):
    """Fix Hackage URLs for local packages in a single HTML file."""

    # Determine which package directory this file is in
    try:
        relative = html_file.relative_to(haddock_root)
        current_package = relative.parts[0] if relative.parts else None
    except ValueError:
        current_package = None

    # Only process files in our package directories
    if current_package not in LOCAL_PACKAGES:
        return False

    content = html_file.read_text(encoding='utf-8')
    modified = False

    # Map of module prefixes to their package names
    MODULE_TO_PACKAGE = {
        'Hindsight-Store-Memory': 'hindsight-memory-store',
        'Hindsight-Store-Filesystem': 'hindsight-filesystem-store',
        'Hindsight-Store-PostgreSQL': 'hindsight-postgresql-store',
        'Hindsight-Projection': 'hindsight-postgresql-projections',
    }

    # Replace Hackage URLs for each local package
    for pkg in LOCAL_PACKAGES:
        # Pattern: https://hackage.haskell.org/package/PKG-VERSION/docs/MODULE.html
        pattern = rf'https://hackage\.haskell\.org/package/{re.escape(pkg)}-[^/]+/docs/'

        if current_package == pkg:
            # Same package - use relative path in same directory
            replacement = ''
        else:
            # Different package - use relative path to sibling directory
            replacement = f'../{pkg}/'

        new_content = re.sub(pattern, replacement, content)
        if new_content != content:
            content = new_content
            modified = True

    # Fix plain module references (e.g., href="Hindsight-Store-Memory.html")
    # These are generated when a module is referenced but not a dependency
    for module_prefix, target_pkg in MODULE_TO_PACKAGE.items():
        if current_package == target_pkg:
            continue  # Same package, link is already correct

        # Match href="ModulePrefix*.html" but NOT href="../anything/" or href="http"
        pattern = rf'href="(?!\.\./)(?!http)({re.escape(module_prefix)}[^"]*\.html)"'
        replacement = f'href="../{target_pkg}/\\1"'

        new_content = re.sub(pattern, replacement, content)
        if new_content != content:
            content = new_content
            modified = True

    if modified:
        html_file.write_text(content, encoding='utf-8')
        return True

    return False

def main():
    if len(sys.argv) != 2:
        print(f"Usage: {sys.argv[0]} HADDOCK_DIR", file=sys.stderr)
        sys.exit(1)

    haddock_dir = Path(sys.argv[1])

    if not haddock_dir.is_dir():
        print(f"Error: {haddock_dir} is not a directory", file=sys.stderr)
        sys.exit(1)

    # Process all HTML files
    fixed_count = 0
    for html_file in haddock_dir.rglob('*.html'):
        if fix_links_in_file(html_file, haddock_dir):
            fixed_count += 1

    print(f"Fixed links in {fixed_count} files")

if __name__ == '__main__':
    main()